/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */
#include <stm32h7xx.h>
#include <stdint.h>
#include <math.h>

#include <board.h>
#include <board_functions.h>
#include <LCD_out.h>
#include <LCD_draw_lib.h>


#if !defined(__SOFT_FP__) && defined(__ARM_FP)  // make sure fp ops available
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

#define BLACK  		   0x0000
#define RED  	       0xF800
#define MNIGHTBLUE     0x4000
#define GREEN  		   0x07E0
#define YELLOW  	   0x07FF
#define MAGENTA 	   0xF81F
#define CYAN   	 	   0xFFE0
#define WHITE 		   0xFFFF
#define GREEN2 		   0x2FA4
#define CYAN2 		   0x07FF
#define BLUE  		   0xFA20

#define LCD_hight      239
#define LCD_with       319



uint8_t flappy(void);  // Prototyp-Deklaration
uint8_t bird(void);  // Prototyp-Deklaration




uint8_t tubespace;
uint8_t xposofst;



typedef struct {  //typedef to call struct by gappos
    uint8_t gaplow;  // vall
    uint8_t gaphigh;     // valh
} gappos;
















gappos tuberand(void){  // call RNG to work;    create 2 rand vals with def space inbetw
//min !must! be in range of LCD hight = 0 to (240 - 1)
                                           //
	uint32_t val = RandomNG();            //                                                                ____________________________________
    //                  max    min + 1     //                                                                \                 /                |
	uint8_t vall = (val % (LCD_hight - tubespace + 1));   // shrink val to LCD writeable space  vall % 190 ->  (2^32 - 1) - {[(2^32 - 1) / 190] - residual of} * 190  = (0,...,239)
	uint8_t valh = vall + tubespace;


	gappos result;               // result has same type as gappos
	    result.gaplow = vall;    // save vall in gaplow var of struct "result"
	    result.gaphigh = valh;   // save valh in gaphigh var of struct "result"

	    return result;           // return struct "result" -> needs to be saved in struct "gappos" or other struct of same type as gappos


}


uint8_t flappy_pos(uint16_t xpos1, uint8_t ypos1){

	ypos1 = (ypos1 - flappy());
	ypos1 = (ypos1 + bird());
	//int16_t xpos1;
	if(xpos1 > (LCD_with - xposofst)){
		xpos1 = xpos1 + xposofst - LCD_with ;
	}else{
		xpos1 = xpos1 + xposofst;
	}
	int16_t xpos2 = xpos1 + 3;

	Rect(xpos1,xpos2,ypos1,ypos1 + 3,WHITE);

	return ypos1;
}


uint8_t flappy(void){

	return hwswflpy();
}


uint8_t bird(void){
	//program velocity

return 1;
}




int main() {
    DWT_Init();
    board_voltage();
	board_oclk(1);
	board_start();
    LCD_Init();
    delay(1000);
    tubespace = 100;
    xposofst = 59;
    uint8_t flpyh = 119;
    scr_area(0b1,0x13F,0);      //def first line as dummy to keep screen scrollable without artifcts
    Line(0,0,LCD_hight,GREEN);
    uint16_t tbcoun;
	for(;;){
			for(int i = 1;i < LCD_with + 1/*+ 1*/; i++){//
				Line(i,0,LCD_hight,BLACK);
				flpyh = flappy_pos(i, flpyh);
				LCD_Scroll(i);
				delay_u(7500);
				delay_u(7500);
				tbcoun++;
				if(tbcoun == 80){ //&& (i < 320)){
					gappos gappos = tuberand();
					Line(i,0,gappos.gaplow, 204 * i);//

					Line(i,gappos.gaphigh,239, 204 * i);//
					tbcoun = 0;
				}

				if(i == 319){i = 0; if(tubespace > 50){tubespace--;}}
			}

	}


}
