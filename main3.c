/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */
#include <stm32h7xx.h>
//#include "core_cm7.h"     // CMSIS-Core Header f√ºr Cortex-M7
#include <stdint.h>
#include "math.h"

#if !defined(__SOFT_FP__) && defined(__ARM_FP)  // make sure fp ops available
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

volatile _Bool tim2Intrpt_g;
volatile _Bool tim3Intrpt_g;


#define BLACK   0x0000
//#define BLUE    0x001F
#define RED     0xF800
#define RED2    0x4000
#define GREEN   0x07E0
#define YELLOW  0x07FF
#define MAGENTA 0xF81F
#define CYAN    0xFFE0
#define WHITE   0xFFFF
#define GREEN2  0x2FA4
#define CYAN2   0x07FF
#define BLUE    0xFA20

#define LCD_RD   GPIO_ODR_OD3 //Serves as read signal/MCU read data at the rising edge. Pg11 Datasheet
#define LCD_WR   GPIO_ODR_OD0 //Serves as write signal/command at the rising edge
#define LCD_RS   GPIO_ODR_OD3 //D/CX (0=Command/1=Data)
#define LCD_CS   GPIO_ODR_OD1 //Chip Select Pin : Active Low
#define LCD_RST  GPIO_ODR_OD2 //Shield Reset















void DWT_Init(void) {

    CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk; // activate trace and debug
    DWT->CYCCNT = 0;                                // clk cycle cnt = 0
    DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;            // act DWT
}



static inline void delay_cycles(uint32_t cycles) {// Timer in cpu clk cycl
    uint32_t start = DWT->CYCCNT;
    while ((DWT->CYCCNT - start) < cycles) {
        __NOP(); // make it not optimizeable
    }
}











void board_oc(){
volatile int a;
int i;
	/*PWR->CR1 |= (0b11 << 14);    //activate VOS M3 (performance)
	while (1){  //wait for VOS3 mode is active
	 	 a = (PWR->CSR1 >> 14) & 0b1;
		if(a == 1){break;}}*/
//_____________________________________________________________________________________________


RCC->CR &= ~(0b1 << 24);         // turn PLL1 off

FLASH->ACR &= ~(0b1);  //Flash standard 7 wait cycles refere page 166 in RM


//Instruction on p.329
    RCC->APB4ENR |= 0b10;        //SYSCFGEN bit set



  /*  a = PWR->CR3;             // save register in a; to change things step by step. wrong values cause register Lock
    a = a & ~(0b11 << 1);     // LDO and SD Bits off
    a = (a |= (0b1       |     // BYPASS bit to 1
    		 (0b1 << 5) |     // 2,5V input for step down conv
			 (0b1 << 3)));     // slightly raise of Vcore -> more stable*/
    PWR->CR3 = (PWR->CR3 &
    			~(PWR_CR3_LDOEN))            |
				PWR_CR3_SMPSLEVEL_1          |
				PWR_CR3_SMPSEXTHP            |
				PWR_CR3_SMPSEN               |
				PWR_CR3_BYPASS;                 // neccesary for VOS0


    //Instruction on p. 297
	PWR->D3CR |= (0b11 << 14);   //VOS1 Mode set
	//while(1){a = ()
	SYSCFG->PWRCR |= 0b1;        //VOS0 Mode set (Boost Mode)
	while(1){a = (PWR->D3CR >> 13) & 0b1; if(a == 1){break;}}

  //HSI selected by default (00)
	//clk input divider -> 16MHz input
	RCC->PLLCKSELR &= ~((0b11 << 8) | (0b11 << 16) | (0b11 << 24));    // PRE 32 -> 0 for DIVM 1,2,3
	RCC->PLLCKSELR |= (0b1 << 6) | (0b1 << 14) | (0b1 << 22); // PRE = 4 for DIVM 1,2,3


	//Freq calculation   PLL1 = HSI/DIVM*(DIVN+(FRACN/2^13))/DIVP     p.436 RM

	//RCC->PLL1FRACR |= (0b1 << 15); //Frac = 4096 -> 456 ->460MHz clk   (2^13 -1 max)

    RCC->PLL1DIVR &= (0b1 << 31) | (0b1 << 23);  // all 0 without changing res Bits 31;23
    RCC->PLL1DIVR |= ((0b110110)   | //DIVN = 54  -> 880MHz
    				  (0b1 << 9)   | //DIVP = 2 -> 440MHz into CLK MUX
					  (0b11 << 16) | //DIVQ = 4 -> 220MHz
					  (0b11 << 24)); //DIVR = 4 -> 220MHz


    RCC->PLL2DIVR &= (0b1 << 31) | (0b1 << 23);  // all 0 without changing res Bits 31;23
    RCC->PLL2DIVR |= ((0b111011)   | //DIVN = 60  -> 960MHz
    				 (0b11 << 9)   | //DIVP = 2 -> 460MHz into CLK MUX
					 (0b11 << 16) | //DIVQ = 4 -> 230MHz
					 (0b11 << 24)); //DIVR = 4 -> 230MHz




	RCC->PLL3DIVR &= (0b1 << 31) | (0b1 << 23);  // all 0 without changing res Bits 31;23
    RCC->PLL3DIVR |= ((0b111011)   | //DIVN = 60  -> 960MHz
			  	  	 (0b11 << 9)   | //DIVP = 2 -> 460MHz into CLK MUX
					 (0b11 << 16) | //DIVQ = 4 -> 230MHz
					 (0b11 << 24)); //DIVR = 4 -> 230MHz



    RCC->PLLCFGR |= (0b11 << 2) | //PLL DIVM (predivider)
    				(0b11 << 6) |
					(0b11 << 10);

    RCC->CR |= (0b1 << 24);         // turn PLL1ON

    while(1) // wait till Flag signaling PLL1 is on
    {a = (RCC->CR >> 25) & 0b1; if(a == 1){break;}}


    RCC->D1CFGR = (RCC->D1CFGR & ~(0b1 << 11)) | 0b1001000; // HPRE /2 & D1PPRE /2
    RCC->D2CFGR |= (0b10001 << 6); // D2PPRE & D2PPRE2 /2
    RCC->D3CFGR |= (0b1 << 6); // D3PPRE /2

    RCC->CFGR |= 0b11;
    while(1)
    {a = (RCC->CFGR >> 3) & 0b11; if(a == 3){break;}}  // wait till SWS == 0b11000 (PLL1 == input)

	a = 0;


}

// DATA Pins |0|1|2|3|4|5|6|7|     || G9|D15|G14|E13|E14|E11|A8|G12
// Function Pins                        RD|WR|RS|CS|RST
//                                      A3|C0|C3|B1|C2

void board_start(){
	RCC->AHB4ENR |= 0b1011111;	    //clk for Ports A,B,C,D,E,G activate
	                                // define pin type
	GPIOA->MODER &= ~((0b1 << 17) | (0b1 << 7)); // Reset is 0b11 (just these); Output 0b01 -> just put "0" in [1:0] position of A8 & A3
	GPIOB->MODER &= ~(0b1 << 3); // B1
	GPIOC->MODER &= ~((0b1 << 7) | (0b1 << 5) | (0b10));   // C0,2,3
	GPIOD->MODER &= ~(0b1 << 31); // D15
	GPIOE->MODER &= ~((0b1 << 29) | (0b1 << 27) | (0b1 << 23));    // E11,13,14
	GPIOG->MODER &= ~((0b1 << 29) | (0b1 << 25) | (0b1 << 19));    // G9,12,14
	//define pin rising/falling edges precision/time
	GPIOA->OSPEEDR |= (0b11 << 3);
	GPIOB->OSPEEDR |= (0b11 << 1);
	GPIOC->OSPEEDR |= ((0b11 << 3) | (0b11 << 2) | 0b11);
	GPIOD->OSPEEDR |= (0b11 << 15);
	GPIOE->OSPEEDR |= ((0b1111 << 26) | (0b11 << 22));
	GPIOG->OSPEEDR |= ((0b11 << 28) | (0b11 << 24));

	RCC->APB1LENR |= RCC_APB1LENR_TIM2EN;     // Timer clk on
	RCC->APB1LENR |= RCC_APB1LENR_TIM3EN;


	SCB->CPACR |= ((3UL << 20) | (3UL << 22));  //activate FPU refere ARM Manual (ARM DUI 0646B ID082615) 4-56
}


void delay(volatile unsigned int ___1) {          //Timer for ms
 RCC->APB1LENR |= RCC_APB1LENR_TIM2EN;
 TIM2->DIER = TIM_DIER_UIE;                         //Update-Interrupt on
 TIM2->CNT = 0;
 TIM2->PSC = 219999;
 TIM2->ARR = ___1;
 tim2Intrpt_g = 0;
 TIM2->CR1 = TIM_CR1_CEN;                          //Timer start

 NVIC_EnableIRQ(TIM2_IRQn);

 do {
 __WFI();
 } while (!tim2Intrpt_g);

 TIM2->CR1 &= ~TIM_CR1_CEN;                        //Timer off

}


void TIM2_IRQHandler(void) {
 tim2Intrpt_g = 1;
 TIM2->SR &= ~TIM_SR_UIF;
}



void delay_u(volatile int ___2) {          //Timer for TFT output freq
 RCC->APB1LENR |= RCC_APB1LENR_TIM3EN;
 TIM3->DIER = TIM_DIER_UIE;                         //Update-Interrupt on
 TIM3->CNT = 0;
 TIM3->PSC = 57 - 1;
 TIM3->ARR = ___2;                                  //1 = 231,82ns
 tim3Intrpt_g = 0;
 TIM3->CR1 = TIM_CR1_CEN;                          //Timer start

 NVIC_EnableIRQ(TIM3_IRQn);

 do {
 __WFI();
 } while (!tim3Intrpt_g);

 TIM3->CR1 &= ~TIM_CR1_CEN;                        //Timer aus

}


void TIM3_IRQHandler(void) {
 tim3Intrpt_g = 1;
 TIM3->SR = 0;
}




void scr_area(uint16_t topcorn, uint16_t Area, uint16_t bottomcorn) {
    LCD_command_write(0x33);
    LCD_data_write(topcorn >> 8);
    LCD_data_write(topcorn & 0xFF);
    LCD_data_write(Area >> 8);
    LCD_data_write(Area & 0xFF);
    LCD_data_write(bottomcorn >> 8);
    LCD_data_write(bottomcorn & 0xFF);
}





void LCD_Scroll(const uint16_t scr_with){ //shifting the starting RAM addr negative
	GPIOB->ODR &= ~LCD_CS;// Chip Select active
	delay_cycles(44);
	//define area where pixels will be changed/written
	LCD_command_write(0x2a);  //code for column address p 110
	LCD_data_write(0x0);  //upper 8 Bit sent to LCD       start addr
	LCD_data_write(0x0);       //lower 8 Bit sent to LCD
	LCD_data_write(0x0);  //
	LCD_data_write(0xF0);       // end addr

	LCD_command_write(0x2b);  //code for row address
	LCD_data_write(0x0);  //
	LCD_data_write(0x0);       //
	LCD_data_write(0x1);  //
	LCD_data_write(0x40);       //
	LCD_command_write(0x37);  // p. 129*/
//                                                      317|318|319|0|1
	LCD_data_write(scr_with >> 8); //                   318|319| 0 |1|2
	LCD_data_write(scr_with & 0xFF);//Start addr after shift-----^

}



 void LCD_write(const uint8_t data) { // inline cause less overhead maybe
    // WR-Pin auf Port C: Wir nehmen an, dass LCD_WR als Bitmaske definiert ist.
    // WR aktiv (Low): Schreibe in den oberen 16 Bit-Bereich (Clear-Bit)
	GPIOC->ODR &= ~LCD_WR; // WR = 0//GPIOC->BSRR = (LCD_WR << 16);    //((uint32_t)LCD_WR << 16);

    //DATA Pins                              0|1  |2  |3  |4  |5  |6 |7
	//										G9|D15|G14|E13|E14|E11|A8|G12
	// Function Pins                        RD|WR|RS|CS|RST
	//                                      A3|C0|C3|B1|C2
    //
    //
    GPIOD->BSRR = ((0b1 << (15)) << 16) |      // top 16bit is reset 1 -> 0 as outp
    			  (((data >> 1) & 0b1) << 15); // lower 16bit is set 1 -> 1 as outp
    // Port G
    {//_______________________________________________________________________________________________//
        const uint32_t clearMaskG = (0b1 << 9)  | 													  //
        							(0b1 << 14) | 													  //
									(0b1 << 12);													  //
        const uint32_t setMaskG = (((data >> 0) & 0b1) << 9)  |										  //
                                  (((data >> 2) & 0b1) << 14) |										  // lets comp know var onl used in here as const
                                  (((data >> 7) & 0b1) << 12);										  //
        GPIOG->BSRR = (clearMaskG << 16) | setMaskG;												  //
    }//_______________________________________________________________________________________________//

    // Port E
    {
        const uint32_t clearMaskE = (0b1 << 13) |
        							(0b1 << 14) |
									(0b1 << 11);
        const uint32_t setMaskE = (((data >> 3) & 0b1) << 13) |
                                  (((data >> 4) & 0b1) << 14) |
                                  (((data >> 5) & 0b1) << 11);
        GPIOE->BSRR = (clearMaskE << 16) | setMaskE;
    }

    // Port A
    {
        const uint32_t clearMaskA = (0b1 << 8);
        const uint32_t setMaskA   = (((data >> 6) & 0b1) << 8);
        GPIOA->BSRR = (clearMaskA << 16) | setMaskA;
    }


    delay_cycles(800); //necces for make TFT working
    GPIOC->ODR |= LCD_WR; // send data after (rising edge)
    delay_cycles(10);
}




void LCD_command_write(const uint8_t command) {
  //  p. 11
  GPIOC->ODR &= ~LCD_RS;

  LCD_write(command);
}

void LCD_data_write(const uint8_t data) {
  //  p. 11
	GPIOC->ODR |= LCD_RS;

  LCD_write(data);
}

void Lcd_Init(void) {
	//Reset TFT
	GPIOC->ODR |= LCD_RST; //active low
	delay(5);
	GPIOC->ODR &= ~LCD_RST; //reset TFT
	delay(15);
	GPIOC->ODR |= LCD_RST; // turn off rst
	delay(15);

	//The below is just preparation for Write Cycle Seq
	GPIOB->ODR |= LCD_CS; //Chip-Select Active Low Signal
	GPIOC->ODR |= LCD_WR;
	delay_u(2);
	GPIOA->ODR |= LCD_RD;
	GPIOB->ODR &= ~LCD_CS;  //cs low to actv ears of controller

	LCD_command_write(0xC5);    //Test this Out | VCOM Control 1 : Colour Contrast Maybe
	LCD_data_write(0x54);       //VCOM H 1111111 0x7F
	LCD_data_write(0x00);       //VCOM L 0000000

	LCD_command_write(0x36);    //Memory Access Control | DataSheet Page 127
	///LCD_data_write(0x48);    //Adjust this value to get right color and starting point of x and y
	LCD_data_write(0b100);  //
	LCD_command_write(0x3A);    //COLMOD: Pixel Format Set  p. 134
	LCD_data_write(0x55);       //16 Bit RGB and MCU
	LCD_command_write(0x11);    //Sleep Out  p. 245
	delay(10);                  //wait at least 5ms after sleepout
	LCD_command_write(0x29);    //Display on.
	LCD_command_write(0x2c);    //Memory Write | DataSheet Page 245
//	LCD_command_write(0x51);    // display brightness
	//LCD_data_write(0xFF);       // brightness = 50%

}

void Pixel(int16_t x1, int16_t y1, int16_t color) {
	const int16_t x2 = x1 + 1; const int16_t y2 = y1 + 1;
	GPIOB->ODR &= ~LCD_CS;// Chip Select active
	//define area where pixels will be changed/written
	LCD_command_write(0x2a);  //code for column address p 110
	LCD_data_write(y1 >> 8);  //upper 8 Bit sent to LCD
	LCD_data_write(y1 & 0xFF);       //lower 8 Bit sent to LCD
	LCD_data_write(y2 >> 8);  // start addr
	LCD_data_write(y2 & 0xFF);       // end addr

	LCD_command_write(0x2b);  //code for row address
	LCD_data_write(x1 >> 8);  //
	LCD_data_write(x1 & 0xFF);       //
	LCD_data_write(x2 >> 8);  //
	LCD_data_write(x2 & 0xFF);       //

	LCD_command_write(0x2c);  // Memory Write
	LCD_data_write(color >> 8);
	LCD_data_write(color);

}


void Line(uint16_t x1, uint16_t y1, uint16_t y2, uint16_t color) {
	const uint32_t pixels = (y2 - y1 + 1);
	const int a = 44;
	GPIOB->ODR &= ~LCD_CS;// Chip Select active
	delay_cycles(22);
	//define area where pixels will be changed/written
	LCD_command_write(0x2a);  //code for column address p 110
	LCD_data_write(y1 >> 8);  //upper 8 Bit sent to LCD
	LCD_data_write(y1 & 0xFF);       //lower 8 Bit sent to LCD
	LCD_data_write(y2 >> 8);  // start addr
	LCD_data_write(y2 & 0xFF);       // end addr

	LCD_command_write(0x2b);  //code for row address
	LCD_data_write(x1 >> 8);  //
	LCD_data_write(x1 & 0xFF);       //
	LCD_data_write(x1 >> 8);  //
	LCD_data_write(x1 & 0xFF);       //

	LCD_command_write(0x2c);  // Memory Write
	for(int i = 0; i < pixels; i++){
		LCD_data_write(color >> 8);
		delay_cycles(a);
		LCD_data_write(color & 0xFF);
		delay_cycles(a);
	}
}

void Rect(uint16_t x1, uint16_t x2, uint16_t y1, uint16_t y2, uint16_t color) {
	const uint32_t pixels = (x2 - x1 + 1) * (y2 - y1 + 1);
	GPIOB->ODR &= ~LCD_CS;// Chip Select active
	delay_cycles(44);
	//define area where pixels will be changed/written
	LCD_command_write(0x2a);  //code for column address p 110
	LCD_data_write((y1 >> 8));  //upper 8 Bit sent to LCD
	LCD_data_write((y1 & 0xFF));       //lower 8 Bit sent to LCD
	LCD_data_write((y2 >> 8));  // start addr
	LCD_data_write((y2 & 0xFF));       // end addr

	LCD_command_write(0x2b);  //code for row address
	LCD_data_write(x1 >> 8);  //
	LCD_data_write(x1 & 0xFF);       //
	LCD_data_write(x2 >> 8);  //
	LCD_data_write(x2 & 0xFF);       //

	LCD_command_write(0x2c);  // Memory Write
	for(int i = 0; i < pixels; i++){
		LCD_data_write(color >> 8);
		LCD_data_write(color & 0xFF);
	}
}

int main() {

    // DWT initialisieren
    DWT_Init();

	board_oc();
	board_start();
    Lcd_Init();
    delay(1000);
	//for(;;){

//Rect(0,320,0,240,BLACK);
delay(100);
for(;;){
        Line(320,0,90, MAGENTA);//}
        Line(320,150,240, GREEN);//}
		Line(305,0,90,BLUE);
		Line(305,150,240,YELLOW);
		delay(10);
		scr_area(0,320,0);
//int a;

		for(int i = 0;i <= 319; i++){
			LCD_Scroll(i + 1);
			delay_u(30);
			Line(i,0,240,RED2);//}
				if(i % 40 == 0){
					//a = i * 40 - 1;
			        Line(i,0,90, 204 * i);//
			        Line(i,150,240, 204 * i);//
				}

			//	RNG p. 1405 RM_________________________________________________________________________________

				if(i == 319){i = 0;}
}

}


}
