/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */
#include <stm32h7xx.h>
#include <stdint.h>
#include "math.h"

volatile _Bool tim2Intrpt_g;
volatile _Bool tim3Intrpt_g;


#define BLACK   0x0000
//#define BLUE    0x001F
#define RED     0xF800
#define RED2    0x4000
#define GREEN   0x07E0
#define CYAN    0x07FF
#define MAGENTA 0xF81F
#define YELLOW  0xFFE0
#define WHITE   0xFFFF
#define GREEN2  0x2FA4
#define CYAN2   0x07FF
#define BLUE    0xFA20

#define LCD_RD   GPIO_ODR_OD3 //Serves as read signal/MCU read data at the rising edge. Pg11 Datasheet
#define LCD_WR   GPIO_ODR_OD0 //Serves as write signal/command at the rising edge
#define LCD_RS   GPIO_ODR_OD3 //D/CX (0=Command/1=Data)
#define LCD_CS   GPIO_ODR_OD1 //Chip Select Pin : Active Low
#define LCD_RST  GPIO_ODR_OD2 //Shield Reset


void board_oc(){
volatile int a;
int i;
	/*PWR->CR1 |= (0b11 << 14);    //activate VOS M3 (performance)
	while (1){  //wait for VOS3 mode is active
	 	 a = (PWR->CSR1 >> 14) & 0b1;
		if(a == 1){break;}}*/
//_____________________________________________________________________________________________


RCC->CR &= ~(0b1 << 24);         // turn PLL1 off

FLASH->ACR &= ~(0b1);


//Instruction on p.329
    RCC->APB4ENR |= 0b10;        //SYSCFGEN bit set



  /*  a = PWR->CR3;             // save register in a; to change things step by step. wrong values cause register Lock
    a = a & ~(0b11 << 1);     // LDO and SD Bits off
    a = (a |= (0b1       |     // BYPASS bit to 1
    		 (0b1 << 5) |     // 2,5V input for step down conv
			 (0b1 << 3)));     // slightly raise of Vcore -> more stable*/
    PWR->CR3 = (PWR->CR3 & ~(PWR_CR3_LDOEN)) | PWR_CR3_SMPSLEVEL_1 | PWR_CR3_SMPSEXTHP | PWR_CR3_SMPSEN | PWR_CR3_BYPASS;            //

	//PWR->CR3 |= (0b1 | (0b1 << 3) | (0b1 << 5));

    //Instruction on p. 297
	PWR->D3CR |= (0b11 << 14);   //VOS1 Mode set
	//while(1){a = ()
	SYSCFG->PWRCR |= 0b1;        //VOS0 Mode set (Boost Mode)
	while(1){a = (PWR->D3CR >> 13) & 0b1; if((a == 1)){break;}}

  //HSI selected by default (00)
	//clk input divider -> 16MHz input
	RCC->PLLCKSELR &= ~((0b11 << 8) | (0b11 << 16) | (0b11 << 24));    // PRE 32 -> 0 for DIVM 1,2,3
	RCC->PLLCKSELR |= (0b1 << 6) | (0b1 << 14) | (0b1 << 22); // PRE = 4 for DIVM 1,2,3

	RCC->PLL1FRACR |= (0b1 << 15); //Frac = 4096 -> 456 ->460MHz clk

    RCC->PLL1DIVR &= (0b1 << 31) | (0b1 << 23);  // all 0 without changing res Bits 31;23
    RCC->PLL1DIVR |= ((0b110101)   | //DIVN = 57  -> 920MHz
    				  (0b1 << 9)   | //DIVP = 2 -> 460MHz into CLK MUX
					  (0b11 << 16) | //DIVQ = 4 -> 230MHz
					  (0b11 << 24)); //DIVR = 4 -> 230MHz


    RCC->PLL2DIVR &= (0b1 << 31) | (0b1 << 23);  // all 0 without changing res Bits 31;23
    RCC->PLL2DIVR |= ((0b111011)   | //DIVN = 60  -> 960MHz
    				 (0b11 << 9)   | //DIVP = 2 -> 460MHz into CLK MUX
					 (0b11 << 16) | //DIVQ = 4 -> 230MHz
					 (0b11 << 24)); //DIVR = 4 -> 230MHz




	RCC->PLL3DIVR &= (0b1 << 31) | (0b1 << 23);  // all 0 without changing res Bits 31;23
    RCC->PLL3DIVR |= ((0b111011)   | //DIVN = 60  -> 960MHz
			  	  	 (0b11 << 9)   | //DIVP = 2 -> 460MHz into CLK MUX
					 (0b11 << 16) | //DIVQ = 4 -> 230MHz
					 (0b11 << 24)); //DIVR = 4 -> 230MHz



    RCC->PLLCFGR |= (0b11 << 2) | //PLL DIVM (predivider)
    				(0b11 << 6) |
					(0b11 << 10);

    RCC->CR |= (0b1 << 24);         // turn PLL1ON

    while(1) // wait till Flag signaling PLL1 is on
    {a = (RCC->CR >> 25) & 0b1; if(a == 1){break;}}

    //Flash standard 7 wait cycles refere page 166 in RM

    RCC->D1CFGR = (RCC->D1CFGR & ~(0b1 << 11)) | 0b1001000; // HPRE /2 & D1PPRE /2
    RCC->D2CFGR |= (0b10001 << 6); // D2PPRE & D2PPRE2 /2
    RCC->D3CFGR |= (0b1 << 6); // D3PPRE /2

    RCC->CFGR |= 0b11;
    while(1)
    {a = (RCC->CFGR >> 3) & 0b11; if(a == 3){break;}}  // wait till SWS == 0b11000 (PLL1 == input)

	a = 0;


}

// DATA Pins |0|1|2|3|4|5|6|7|     || G9|D15|G14|E13|E14|E11|A8|G12
// Function Pins                        RD|WR|RS|CS|RST
//                                      A3|C0|C3|B1|C2

void board_start(){
	RCC->AHB4ENR |= 0b1011111;	    //clk for Ports A,B,C,D,E,G activate
	                                // define pin type
	GPIOA->MODER &= ~((0b1 << 17) | (0b1 << 7)); // Reset is 0b11 (just these); Output 0b01 -> just put "0" in [1:0] position of A8 & A3
	GPIOB->MODER &= ~(0b1 << 3); // B1
	GPIOC->MODER &= ~((0b1 << 7) | (0b1 << 5) | (0b10));   // C0,2,3
	GPIOD->MODER &= ~(0b1 << 31); // D15
	GPIOE->MODER &= ~((0b1 << 29) | (0b1 << 27) | (0b1 << 23));    // E11,13,14
	GPIOG->MODER &= ~((0b1 << 29) | (0b1 << 25) | (0b1 << 19));    // G9,12,14
	//define pin rising/falling edges precision/time
	GPIOA->OSPEEDR |= (0b11 << 3);
	GPIOB->OSPEEDR |= (0b11 << 1);
	GPIOC->OSPEEDR |= ((0b11 << 3) | (0b11 << 2) | 0b11);
	GPIOD->OSPEEDR |= (0b11 << 15);
	GPIOE->OSPEEDR |= ((0b1111 << 26) | (0b11 << 22));
	GPIOG->OSPEEDR |= ((0b11 << 28) | (0b11 << 24));

	RCC->APB1LENR |= RCC_APB1LENR_TIM2EN;     // Timer clk on
	RCC->APB1LENR |= RCC_APB1LENR_TIM3EN;


}


void delay(volatile unsigned int ___1) {          //Timer for ms
 RCC->APB1LENR |= RCC_APB1LENR_TIM2EN;
 TIM2->DIER = TIM_DIER_UIE;                         //Update-Interrupt on
 TIM2->CNT = 0;
 TIM2->PSC = 219999;
 TIM2->ARR = ___1;
 tim2Intrpt_g = 0;
 TIM2->CR1 = TIM_CR1_CEN;                          //Timer start

 NVIC_EnableIRQ(TIM2_IRQn);

 do {
 __WFI();
 } while (!tim2Intrpt_g);

 TIM2->CR1 &= ~TIM_CR1_CEN;                        //Timer off

}


void TIM2_IRQHandler(void) {
 tim2Intrpt_g = 1;
 TIM2->SR &= ~TIM_SR_UIF;
}



void delay_u(___2) {          //Timer for TFT output freq
 RCC->APB1LENR |= RCC_APB1LENR_TIM3EN;
 TIM3->DIER = TIM_DIER_UIE;                         //Update-Interrupt on
 TIM3->CNT = 0;
 TIM3->PSC = 219;
 TIM3->ARR = ___2;                                  //1 = 500ns
 tim3Intrpt_g = 0;
 TIM3->CR1 = TIM_CR1_CEN;                          //Timer start

 NVIC_EnableIRQ(TIM3_IRQn);

 do {
 __WFI();
 } while (!tim3Intrpt_g);

 TIM3->CR1 &= ~TIM_CR1_CEN;                        //Timer aus

}


void TIM3_IRQHandler(void) {
 tim3Intrpt_g = 1;
 TIM3->SR &= ~TIM_SR_UIF;
}





void LCD_Scroll(volatile int scr_with){ //scrolling
	LCD_command_write(0x37);  // p. 129

	LCD_data_write();

}



void LCD_write(uint8_t data) {
	//volatile int D0, D1, D2, D3, D4, D5, D6, D7;
	//volatile int ds[8] = {D7, D6, D5, D4, D3, D2, D1, D0};
	GPIOC->ODR &= ~LCD_WR; // WR = 0
	//delay_2MHz();

	// DATA Pins |0|1|2|3|4|5|6|7|     || G9|D15|G14|E13|E14|E11|A8|G12
	// Function Pins                        RD|WR|RS|CS|RST
	//                                      A3|C0|C3|B1|C2
	/*for(int i = 0; i<8; i++){       // write data into the array
	ds[i+1] = (data >> i) && 0b1;            !!!
	}*/

	GPIOD->ODR &= (~(0b1 << 15));   // set Bit15 to 0
	GPIOG->ODR &= (~(0b101001 << 9));  // set bits 9 , 12, 14 to 0
	GPIOE->ODR &= (~(0b1101 << 11));   // set bits 11, 13, 14 to 0
	GPIOA->ODR &= (~(0b1 << 8));       // set bit 8 to 0

	GPIOD->ODR |= (((data >> 1) & 0b1) << 15);              //
	GPIOG->ODR |= (((data & 0b1) << 9) | (((data >> 2) & 0b1) << 14) | (((data >> 7) & 0b1) << 12));

	GPIOE->ODR |= ((((data >> 3) & 0b1) << 13) | (((data >> 4) & 0b1) << 14) | (((data >> 5) & 0b1) << 11));
	GPIOA->ODR |= ((((data >> 6) & 0b1) << 8));




	//GPIOD->ODR &= 0b1111111100000000;
	//GPIOD->ODR |= data;
	//delay_2MHz();
	GPIOC->ODR |= LCD_WR; // send data
	//delay_2MHz();
}

void LCD_command_write(uint8_t command) {
  //  DataSheet Page 11
  GPIOC->ODR &= ~LCD_RS;

  LCD_write(command);
}

void LCD_data_write(uint8_t data) {
  //  DataSheet Page 11
	GPIOC->ODR |= LCD_RS;

  LCD_write(data);
}

void Lcd_Init(void) {

  //Reset Signal is Active LOW
  GPIOC->ODR |= LCD_RST;
  delay(5);
  GPIOC->ODR &= ~LCD_RST; //Actual Reset Done Here
  delay(15);
  GPIOC->ODR |= LCD_RST;
  delay(15);

  //The below is just preparation for Write Cycle Seq
  GPIOB->ODR |= LCD_CS; //Chip-Select Active Low Signal

  GPIOC->ODR |= LCD_WR;

  GPIOA->ODR |= LCD_RD;

  GPIOB->ODR &= ~LCD_CS;  //Chip-Select Active Low Signal


  LCD_command_write(0xC5);    //Test this Out | VCOM Control 1 : Colour Contrast Maybe

  LCD_data_write(0x54);       //VCOM H 1111111 0x7F

  LCD_data_write(0x00);       //VCOM L 0000000

  //LCD_data_write(B1010011);

  LCD_command_write(0x36);    //Memory Access Control | DataSheet Page 127

  ///LCD_data_write(0x48);       //Adjust this value to get right color and starting point of x and y
  LCD_data_write(0b0000100);     //Example


  LCD_command_write(0x3A);    //COLMOD: Pixel Format Set | DataSheet Page 134

  LCD_data_write(0x55);       //16 Bit RGB and MCU


  LCD_command_write(0x11);    //Sleep Out | DataSheet Page 245
  delay(10);                  //Necessary to wait 5msec before sending next command

  LCD_command_write(0x29);    //Display on.


  LCD_command_write(0x2c);    //Memory Write | DataSheet Page 245

}

void Address_set(int16_t y1, int16_t y2, int16_t x1, int16_t x2) {
  LCD_command_write(0x2a);  //Column Address Set | DataSheet Page 110

  LCD_data_write(y1 >> 8);  //upper 8 Bit sent to LCD

  LCD_data_write(y1);       //lower 8 Bit sent to LCD

  LCD_data_write(y2 >> 8);  //8 Bit Shift Right of y2

  LCD_data_write(y2);       //Value of y2


  LCD_command_write(0x2b);  //Row Address

  LCD_data_write(x1 >> 8);  //

  LCD_data_write(x1);       //

  LCD_data_write(x2 >> 8);  //

  LCD_data_write(x2);       //


  LCD_command_write(0x2c); // REG 2Ch = Memory Write


}

void Pixel(int16_t x, int16_t y, uint16_t color) {
	GPIOB->ODR &= ~LCD_CS;// Chip Select active

  Address_set(y, y + 1, x, x + 1);
  LCD_data_write(color >> 8);
  LCD_data_write(color);

}

void Line(int16_t xs, int16_t xe, int16_t ys, int16_t ye, uint16_t color) {
	GPIOB->ODR &= ~LCD_CS;// Chip Select active

  Address_set(ys, ye, xs, xe);
  LCD_data_write(color >> 8);
  LCD_data_write(color);
}

int main() {
	board_oc();
	board_start();

	for(;;){
    Lcd_Init();
      for(int i = 0; i < 240; i++){
    	  for(int i1 = 0; i1 < 320; i1++){
    	  Pixel(i1, i, BLACK);
    	  //delay(1);
    	  }
      }

delay(1000);


            }

}
